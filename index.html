<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animations</title>
    <link rel="stylesheet" href="styles/style.css">
    <script src="scripts/index.js" defer></script>
</head>

<body>
    <button id="toggle-rain-btn">Toggle rain</button>
    <div class="rain-container"></div>
    <pre>.rain-container {
    display: grid;
    grid-template-columns: repeat(auto-fill, 20px);
    grid-auto-rows: 20px;
    gap: 5px;
}

.rain {
    border-radius: 0 10px 10px 10px;
    background-image: linear-gradient(to right, lightblue, cyan);
}

.raining {
    animation: rain 3s infinite ease-in-out alternate;
}

@keyframes rain {
    to {
        transform: translate(0, 100vh) skewY(90deg);
    }
}

/* JS */
const toggleRainButton = document.querySelector('#toggle-rain-btn');
toggleRainButton.onclick = () => {
    const rains = document.querySelectorAll('.rain');
    rains.forEach(rain => rain.classList.toggle('raining'));
}

const rainContainer = document.querySelector('.rain-container');
for (let i = 0; i &lt;= 30; i++) {
    const rain = document.createElement('div');
    rain.classList.add('rain');
    rainContainer.appendChild(rain);
}</pre>
    <hr>
    Starting
    <a href="https://www.youtube.com/watch?v=zHUpx90NerM">
        CSS3 Animation & Transitions Crash Course by Traverst Media
    </a>
    <h1 class="pausable">Let's animate stuffs!</h1>
    <p>
        In CSS, there are 2 main ways to move things around the page:
    </p>
    <ul>
        <li>Transition Property</li>
        <li>Animation Property + Keyframes</li>
    </ul>
    <pre>h1 {
    position: relative;
    text-align: center;
    max-width: 50%;
    animation-name: main-header;
    animation-duration: 5s;
    animation-iteration-count: infinite;
    animation-delay: 3s;
    animation-direction: alternate;
    animation-timing-function: ease-out;
}

@keyframes main-header {
    0% {
        background-color: hotpink;
        transform: translate(0, 0);
    }
    25% {
        background-color: thistle;
        transform: translate(50%, 0);
    }
    50% {
        background-color: lime;
        transform: translate(50%, 10vh);
    }
    75% {
        background-color: cyan;
        transform: translate(0, 10vh);
    }
    100% {
        background-color: hotpink;
        transform: translate(0, 0);
    }
}</pre>
    <div class="centered-circle pausable" id="morphing-circle"></div>
    <pre>#morphing-circle {
    background-image: linear-gradient(to right, darkcyan, cyan);
    position: relative;
    left: calc(50% - 10vw);
    height: 20vw;
    width: 20vw;
    animation-name: morphing-circle;
    animation-duration: 5s;
    animation-iteration-count: infinite;
    animation-direction: alternate;
    animation-timing-function: ease-out;
}

@keyframes morphing-circle {
    0% {border-radius: 0 0 0 0;}
    25% {border-radius: 50% 0 0 0;}
    50% {border-radius: 50% 50% 0 0;}
    75% {border-radius: 50% 50% 50% 0;}
    100% {border-radius: 50% 50% 50% 50%;}
}</pre>
    <div class="centered-circle" id="transition-1">Hold</div>
    <pre>#transition-1 {
    transition-property: background-color, border-radius, transform;
    transition-duration: 2s, 3s, 4s;
}

#transition-1:active {
    background-color: limegreen;
    border-radius: 50%;
    transform: rotateZ(180deg);
}</pre>
    End of
    <a href="https://www.youtube.com/watch?v=zHUpx90NerM">
        CSS3 Animation & Transitions Crash Course by Traverst Media
    </a>
    <hr>
    Starting
    <a href="https://www.youtube.com/watch?v=8kK-cA99SA0">CSS Transitions</a>
    Syntax for applying transition:
    <pre id="one-line-transform">.element {
    /* transition: [property] [duration] [ease] [delay]; */

    #one-line-transform {
        transition: opacity 1s ease-in 100ms;
    }

    #one-line-transform:hover {
        opacity: 0;
    }    
}</pre>
    <p>
        We declare the transition property on the element that we want to move. Note that every element is not
        animatable. Things we can animate include:
    </p>
    <ul>
        <li>font-size</li>
        <li>background-color</li>
        <li>width</li>
        <li>left</li>
    </ul>
    <p>
        These things do not cause a repaint, or reflow of the layout. Things we can't animate:
    </p>
    <ul>
        <li>display</li>
        <li>font-family</li>
        <li>position</li>
    </ul>
    <p>
        If you animate anything other than translation, scale, rotation and opacity, you are at risk of not hitting
        60fps mark.
    </p>
    <p>
        Main ways of triggering these transitions are to hover over things and use classes. Remember
        <code>pointer-events</code>. Its a big one.
    </p>
    <div class="centered-circle clickbait">
        <div>Clickbait!</div>
    </div>
    <pre>.clickbait {
    border: 10px double orange;
    display: flex;
    background-color: pink;
}

.clickbait div {
    flex: 1;
    transition: background-color 500ms ease-in, transform 500ms ease-in;
    pointer-events: none;
}

.clickbait.clicked div {
    transform: translate(50px, 50px) rotate(90deg);
    background-color: darkseagreen;
}

/* JS */
const clickbait = document.querySelector('.clickbait');
clickbait.onclick = () => {
    clickbait.classList.toggle('clicked');
};</pre>
    <p>
        In order to use the <code>animation</code> property, we need to use something called <code>keyframe</code>.
        Keyframes don't have any selectors on them, they are not nested inside anything, they are placed at the root of
        the css file.
    </p>
    <div class="one-line-animation pausable">Ease</div>
    <pre>.one-line-animation {
    animation: expand-width 4s ease-in infinite alternate;
    transform-origin: 0 0;
    background-color: plum;
}

@keyframes expand-width {
    from {
        transform: scaleX(0);
    }
    to {
        transform: scaleX(1);
    }
}</pre>
    <div class="container-grid"></div>
    <pre>.container-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, 10vw);
    grid-auto-rows: 10vw;
    gap: 10px;
    min-height: 100px;
}

.emerging-box {
    animation: emerging-box 1s ease-in infinite alternate;
}

@keyframes emerging-box {
    from {transform: scale(0);}
    to {transform: scale(1);}
}

/* JS */
const containerGrid = document.querySelector('.container-grid');
containerGrid.onclick = () => {
    const emergingBox = document.createElement('div');
    emergingBox.style.backgroundColor = `rgb(${getRandom(0, 256)}, ${getRandom(0, 256)}, ${getRandom(0, 256)})`;
    emergingBox.classList.add('emerging-box');
    emergingBox.classList.add('pausable');
    containerGrid.appendChild(emergingBox);
}</pre>
    End of
    <a href="https://www.youtube.com/watch?v=8kK-cA99SA0">CSS Transitions</a>
    <hr>
    Beginning
    <a href="https://www.youtube.com/watch?v=Nloq6uzF8RQ">Animating with CSS transitions</a>
    <div class="timing-functions">
        Various <code>animation-timing-function</code>s:
        <dl>
            <dt>ease</dt>
            <dd></dd>
            <dt>ease-in</dt>
            <dd></dd>
            <dt>ease-out</dt>
            <dd></dd>
            <dt>ease-in-out</dt>
            <dd></dd>
            <dt>linear</dt>
            <dd></dd>
        </dl>
    </div>
    End of
    <a href="https://www.youtube.com/watch?v=Nloq6uzF8RQ">Animating with CSS transitions</a>
    <hr>
    Starting
    <a href="https://developers.google.com/web/fundamentals/design-and-ux/animations/css-vs-javascript">
        CSS animations vs JS animations
    </a>
    <br>
    <p>
        Some properties are more expensive to change than others, and are therefore more likely to make things stutter.
        So, for example, changing the box-shadow of an element requires a much more expensive paint operation than
        changing, say, its text color. Similarly, changing the width of an element is likely to be more expensive than
        changing its transform. If you want the TL;DR, stick to transforms and opacity changes, and use will-change.
    </p>
    <ul>
        <li>
            CSS transitions and animations are ideal for bringing a navigation menu in from the side, or showing a
            tooltip. You may end up using JavaScript to control the states, but the animations themselves will be in
            your CSS.
        </li>
        <li>
            Use JavaScript when you need significant control over your animations. The Web Animations API is the
            standards-based approach, available today in most modern browsers. This provides real objects, ideal for
            complex object-oriented applications. JavaScript is also useful when you need to stop, pause, slow down, or
            reverse your animations.
        </li>
        <li>
            Use requestAnimationFrame directly when you want to orchestrate an entire scene by hand.
        </li>
    </ul>
    End of
    <a href="https://developers.google.com/web/fundamentals/design-and-ux/animations/css-vs-javascript">
        CSS animations vs JS animations
    </a>
    <hr>
</body>

</html>